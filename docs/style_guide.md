# Coding Style

## ファイル内での要素配置順序

ファイル内で複数の要素（クラス、関数、定数など）を記述する際は、以下の順序に従ってください：

1. 規模の大きいもの（主要なクラスや関数）を上部に配置
2. より小さいもの、または依存関係のあるものを中間に配置
3. 定数や設定値を配置
4. エラークラスは最下部に配置

この順序に従うことで、以下の利点があります：
- コードの全体構造が把握しやすくなる
- 重要な要素が最初に目に入る
- 依存関係が明確になる
- 例外処理に関する情報が一箇所にまとまる

例：

```python
# 1. 主要なクラス
class MainClass:
    # ...

# 2. 補助的なクラス
class SubClass():
    # ...

# 3. 定数
CONSTANT_VALUE = 42

# 4. エラークラス
class CustomError(Exception):
    # ...
```
    
## ドメインモデル設計

ドメインモデルを設計する際は、以下のガイドラインに従ってください：

1. ID フィールド
   - すべてのエンティティは必須の ID フィールドを持つこと
   - ID は意味を持たない値であるべき (UUID等)

   ```go
   type Tag struct {
       Id string
   }
   ```

2. プライマリーキーと ID の区別
   - 一意なフィールドを示すためのプライマリーキーを設けることは許可
   - ただし、プライマリーキーを ID として使用してはならない

   ```go
   type Tag struct {
        Id string
        Name string // Name をプライマリーキーとして使用可能だが、ID ではない
   }
   ```

3. 複数エンティティの扱い
   - 複数のエンティティを扱う際は基本的にスライスを使用
   - マップの使用は避ける

   ```go
   // 良い例
   tags := []*Tag{}

   // 避けるべき例
   nameTagMap := make(map[string]*Tag)
   for _, tag := range tags {
       nameTagMap[tag.Name] = tag
   }
   ```

これらのガイドラインに従うことで、以下の利点があります：
- エンティティの一貫した識別が可能になり、変更に強い
- データ構造の一貫性が保たれ、操作がシンプルになる

## パッケージ配置ルール

### 1. 柔軟なカテゴライゼーション

- 理解しやすさを重視し、自由度の高いカテゴライゼーションを許容する。
- 抽象的すぎる概念でのカテゴライゼーションは避ける。
- パッケージの入れ子構造を許可する（例：バックエンドパッケージ内にフロントエンドを含む）。
- 自分にとって意味のあるカテゴライズを考えて、適切な場所にpackageを配置した後、対応するpackage管理ツールで登録を行う。

### 2. マルチ言語対応

- 言語ごとにworkspace管理ツールが違う、packageを追加する時に言語ごとの管理ツールで登録する必要がある。
  - phpの場合は`workspace.php`
  - pythonの場合`pyproject.toml`
  - tsの場合`package.json`
  - goの場合`go.work`
  - leanの場合`lakefile.lean`
- 同一機能を異なる言語で実装する可能性を考慮する。
- 言語別のサブディレクトリを使用し、共通のパッケージ名を維持する。
  例：
  ```
  my-package/
  ├── go/
  │   └── (Goの実装)
  ├── python/
  │   └── (Pythonの実装)
  └── ts/
      └── (TypeScriptの実装)
  ```
- フォルダ名は必ずしもパッケージ名を反映しない。

### 3. 将来的なカテゴライゼーション

- 現在のプロジェクト構造は、npmのturborepoの慣例に倣って以下のように整理されています：
  - `apps/`: 完全なアプリケーション
  - `packages/`: 他のアプリケーションから呼び出される共有ライブラリ等
- プロジェクトの成長に応じて、より適切なカテゴライゼーションを検討する。
  （例：`packages/platforms`, `packages/sdks`, `services`, `frameworks`など）

### 注意事項

- カテゴライゼーションは定期的に見直し、必要に応じて調整する。
- 新しいパッケージを追加する際は、これらのルールに従いつつ、プロジェクト全体の一貫性を保つ。
- ドメイン駆動の分類を優先し、技術的な分類（言語やUIフレームワークなど）は二次的に考慮する。

## パッケージのルール

### 1. モジュールに分ける

- フロントエンドはレイヤー別
- バックエンドはドメイン別
- ライブラリやフレームワークやsdkは機能別等
- 意味のあるフォルダ名を使用する、設計思想の用語や技術用語は基本的にフォルダ名に含まない
- index.ts を使って、フォルダ単位で import 可能にする

### 2. Clean Architecture

- インフラ層はアプリケーション層で定義されたインターフェースに合わせて実装
- インフラ層がドメインを import する

### 3. パッケージ公開

- package.json で適切にパスを公開する
- project rootにある言語ごとのworkspaceファイルにpackageを登録

### 4. その他

- 固有名詞でなければinterface、固有名詞ならば実装
- エラーメッセージは小文字から初めてピリオド不要