# メモアプリ

## Contents

## 動機

### こだわりとの向き合い方

私は変なこだわりや完璧主義があるせいで、ノートの構成等が気になってしょうがないからノートをとるのが苦手である。

自身のこだわりをなんとかする上で、こだわりを捨てようとするのではなく、こだわりを持つ場所を選ぶことがとても大切だと気づいた。

例えば、こだわることを間違えている例として、通学ルートがある。毎日同じルートでないと気がすまない人はとても生きづらいと思う。

ではこだわってよい場所というのはどこかというと、DDDやClean Architectureにおけるドメインレイヤである。

最も抽象的であるドメインレイヤが最も大切であり、**実装はドメインを満たすものならなんでもよい**という考え方が、人生にもあてはまる。

例えば通学の例でのドメインは「時間までに学校に到着する」ことであり、そのための**手段・実装はなんでもよい**というのが、ドメインにこだわることである。

### 抽象とは

まずドメインレイヤとはなにか、ひいては抽象とはなにかをはっきりさせよう。

万物は、型を受け取って型を出力する関数である。

現実的には、入力と出力と境界条件で万物が定義できる。

例えば、競技プログラミングの問題もすべてその形式である。

ここで、より広い型を扱える関数およびその型自体がより抽象である。

そしてドメインレイヤを考えたり抽象化を考えることは、この型定義をどうするか考えることである。

プログラムの設計では、最初にinterfaceやdomain modelを考えることが抽象化である。

また、型定義とカテゴライズは同義であり、資料整理なども型定義とやってることは一緒と言える。

### メモは抽象化できない

よくあるメモアプリの一種がカレンダーアプリであるが、カレンダーアプリでは日付だけがすべてのデータのkeyとなっており、内容は自由である。

カレンダーアプリの内容をカテゴライズすることを想像してみると、とてもむずかしい上にあまり意味がないことがわかる。

カレンダーに書くような重要度も内容も全然違う細々した情報を完全にカテゴライズすることはとても難しい上に、手軽さが大事なので、カテゴライズや型定義やこだわりといった考えは障害にしかならない。

抽象化や型定義やカテゴライズは、メモの中から今後も必要な情報を抽出した後に行われるべき作業で、メモを取るときにいちいち綺麗さにこだわって抽象化を行うことは間違いである。

例えば、「バイトで言われたことを急いでメモしないといけない、それを一週間後に思い出す必要がある」、といった場合に、きれいに抽象化したりカテゴライズして美しいメモを取ることは間違いである。

とにかく手軽にメモを取ることが大事であり、家に帰った後で必要な情報だけ抽出して抽象化やカテゴライズを行うべきである。

近年増えているメモアプリはこの手軽さを軽んじている。NotionやObsidianなどのアプリを見ると、メモを上手にカテゴライズして美しく書こうという風潮があるが、これは間違いである。

Notionで作文するより、ツイッターでつぶやくほうが、メモを取る上で便利なのである。

**書きたいときに手軽に書ける**ことが最も大事であり、さらに**必要に応じて後から整理できる**ことが大事である。

### CQRSとイベントソーシング

アルバイトの例をどうすればいいかというと、イベントストアとCQRSを使う。

その場では起こったことをそのままイベントとしてメモに残し、後で必要に応じてそのデータに取捨選択、カテゴライズ、抽象化といったprojectionを行ってきれいなノートを作るのである。

また、人生に起こったことを人力ですべてメモしても大した量にならないというのも重要で、雑多なイベントをすべて、一切削除することなく生涯書き足し続けることが大切である

これを読んで少しでも共感した人がいれば、書いたものを消さない、すべて残す、潔癖や完璧主義をやめて落書きや黒歴史もすべて残すというのを意識してみてもらいたい、いらないと思っていた情報がいつかきっと役に立つかもしれないのである。

そしてそのようなイベントデータとは別で、きれいに構築されたReadModelというのを必要に応じてprojectionによって作るという考え方が大切である。

何でもありなら白紙に落書きするのが最良ということになってしまうが、めちゃくちゃ悩んだ末にこれだけは言えるという、万物に適用できるメモアプリの型定義を考えたので、そのような、ある程度形式化された綺麗に書けるメモアプリを作りたい。

### メモアプリのアーキテクチャ

上で抽象化が難しいと言ったメモを頑張って抽象化して型定義を考えた結果、入力、出力、境界条件という３つの要素とその依存関係で表現できることに気づいた。

ただし、適当にメモに書きたい内容を考えてみてそれを入力、出力、境界条件で表現することを考えると、これが意外と難しいことがわかる。

でも頑張ればあらゆるメモしたいデータをこの３つで表現できると思うし、そもそも物事を入力、出力、境界条件としてモデル化して考える事自体とても大切な能力なのでぜひ練習すべきである。

よってすべてのメモをシーケンスデータとしてこの形式で残す仕様とする。

また、それぞれのデータの依存関係については、有向非巡回グラフで表現できる。

循環するメモは存在しない上に、順序付きタスクのを表現するのに有向非巡回グラフは適しているため、これをメモのリストアップに使用する。

また、**メモのprojectionをplugin systemで出来たらいい**なとも思っている。

## アプリ概要

シーケンスデータからなるDAGでイベントデータを管理する

[有向非巡回グラフの説明](https://qiita.com/maebaru/items/5b6cb981777624ab843c)

[順序づけする必要があるタスクの集合は、あるタスクが他のタスクよりも前に行う必要があるという制約により、頂点をタスク、辺を制約条件で表現すると有向非巡回グラフで表現できる。](https://ja.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E9%9D%9E%E5%B7%A1%E5%9B%9E%E3%82%B0%E3%83%A9%E3%83%95)

[有向非巡回グラフを理解するための例題1](https://leetcode.com/problems/course-schedule/description/)

[有向非巡回グラフを理解するための例題2](https://leetcode.com/problems/course-schedule-ii/description/)

## コンポーネント
* 構造体で入力や出力を定義
* インターフェースで入力と出力の関係を定義
* DAGで命題(タスク)の依存関係を定義

## イベントの型
* 入力(前提,現状)
* 出力(帰結,結論)
* 境界条件
* 実装はかかない！

## 補題

### 読み取り
* 有向非巡回グラフを構築できる人
* 有向非巡回グラフの構築に必要な情報を読み取れるリポジトリ
* 画面を表示する人

### 書き込み
* イベント
    * 公開範囲を指定したい
    * 書き込みたい
    * 編集したい
* 依存関係
    * イベント追加時に合わせて追加したい
        * startまたはendを複数指定して、自身をendまたはstartとしたedgeを追加できる
    * 編集したい
        * 複数のstartと複数のendを指定して直積がとれる
        * 複数のstartと複数のendを指定して直積をとってすべて削除
