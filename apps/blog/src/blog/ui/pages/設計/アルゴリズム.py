import streamlit as st

"""
# 設計で使用するアルゴリズム

## コンポーネント分離

### vertical
* 複数個所で出現する共通部分をまとめたもの: model, hook, wrapper, util, gateway, middleware
    * これらのコンポーネントはhorizontalな分割においては特定の役割に限定し辛い場合や冗長になる場合がある
* 横断的な関心毎: entrypoint, kernel
    * 一般的すぎる役割
* まとめた方が分かりやすくなるもの: dbadapter
    * infraやフレームワークを使ったドメインの実装では、infraが変わると丸ごと入れ替わる、特にdbadapter等頻出するものについて、独立したmoduleを作ってhorizontalにまとめる方がいい

### horizontal
* ドメインの補題分割によるコンポーネント
* 人に例えた時、それぞれの役割を担う人々
* 特別な理由がない場合horizontalに分ける努力をする

## フォルダの切り方

### **手順**

#### **ステップ 1: ドメインツリーの構築**
- **目的**: サービスの完成をルートノードとし、ドメインやサブドメインを定義する。
- **手順**: 再帰的な補題分轄を行いドメインツリーを構築、各ドメインやサブドメインをディレクトリ構成に反映する。
    - サービスの完成をルートノードとして捉える
    - ルートノードの実現に必要な主要な機能を大きなサブドメインとして定義する
    - 再帰的にサブドメインへの分轄を行う
    
#### **ステップ 2: 2つのルールの適用**

以下の2つのルールを各サブドメインで適用する

- **ルール 1: 共通化されたモジュールの定義**
  - **条件**: 複数のドメインで共通して利用される機能やリソースが存在する。
  - **処理**: その機能やリソースを表す概念をフォルダとして定義し、共通化されたモジュールとする。
- **ルール 2: 専門家による実装のまとめ**
  - **条件**: 同じ技術や専門知識を必要とする実装が複数のドメインで存在する。
  - **処理**: その実装を専門家が管理する具体的な名前のフォルダにまとめる。
  
#### **ステップ 3: 横断的な関心事のフォルダを作る**

entrypoint, kernel, gateway等

---

### **具体例: オンラインショッピングサービスのフォルダ構成**

#### **ステップ 1: ドメインツリーの構築**
- **ルートノード**: オンラインショッピングサービスの完成。
- **補題**: ユーザー管理、商品管理、注文処理、支払い処理、認証

```
online_shopping/
  ├── auth/
  ├── user_management/
  ├── product_management/
  ├── order_processing/
  └── payment_processing/
```

---

#### **ステップ 2: 2つのルールの適用**

##### **ルール 1: 共通化されたモジュールの定義**
- **条件**: ログ機能がすべてのドメインで必要。
- **処理**: ログ機能を `logging/` フォルダにまとめる。

```
online_shopping/
  ├── auth/
  ├── user_management/
  ├── product_management/
  ├── order_processing/
  ├── payment_processing/
  └── logging/
```

##### **ルール 2: 専門家による実装のまとめ**
- **条件**: データベースを使った実装がユーザー管理、商品管理、注文処理で必要。
- **処理**: データベースを使った実装を `database/` フォルダにまとめる。

```
online_shopping/
  ├── auth/
  ├── user_management/
  ├── product_management/
  ├── order_processing/
  ├── payment_processing/
  ├── logging/
  └── database/
```

#### **ステップ 3: 横断的な関心事のフォルダを作る**

entrypoint、api、gatewayなどのフォルダが生える

---

### **まとめ**
1. **ステップ 1**: ドメインツリーを構築し、各ドメインやサブドメインを反映する。
2. **ステップ 2**: 2つのルール（共通化されたモジュールの定義と専門家による実装のまとめ）を適用し、必要に応じてフォルダを追加する。

## その他のテクニック

### CQRS & Event Driven

#### CQRS
* commadに対しては必要十分なデータを完結に書き込む
* queryに対しては読み取りたいデータを読み取りたい形で取得する
* データの変換処理として、projectionサービスの作成やviewの構築を行う
* commandではEntityやValueObjectなどでカプセル化する際にvalidationを行うが、queryではvalidationは基本的に行わない

#### Event Driven
* command serviceで書き込むのに必要十分なデータを考える上でEventを考える
* Eventとはコマンド処理結果を表す事後イベントのこと、起こったことをすべて残すことが完全な設計であるが、それが冗長すぎる場合は臨機応変にスキーマを考える
* 例えば[akinator](https://akinator.mictlan.site)の設計では質疑の結果をすべて保持しているが、koemadeのプロフィールでは単純にプロフィールの最終状態を保持している
* 更に大規模な場合、gatewayとservice(冒険者)という２つの概念が登場する
  * 注文フローといった他段階のタスクに対して、一つの冒険者がすべての処理を頑張るのではなく、それぞれのステップを担当する専門家の冒険者を用意する
  * gatewayを通ったデータを最初の冒険者が受取り、必要な処理を行う。
  * 冒険者は、処理の結果のイベントを冒険者専用ギルド掲示板(broker)に書き込む
  * 他の冒険者は掲示板を常にチェックしており、自分に役割に対応するイベントが貼られていれば、それをconsumeして処理を行い、まだやることがある場合掲示板に自分の作業の結果を書き込む

### callback
setterをcallbackに渡すことでデータバインディング等できる

### statemachine
callbackと組み合わせることで状態の不整合がないUIが作れる

### reducer pattern
複雑な複合状態は集約で管理する、これもcallbackと組み合わせることで状態の不整合がないUIが作れる

### tensor
* 同じことの繰り返しではなく、それぞれを一意に決定するための各種indexを次元とする空間同士の演算として捉える
* tupleによる複合鍵とviewを使えば任意の次元の組み合わせによる任意の形でのテンソルのアクセスがO(1)で可能

"""
